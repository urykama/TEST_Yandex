*	
Опишите словами алгоритм решения задачи
Ввод: натуральное число n
Вывод: количество простых чисел строго меньше n
Решение должно быть вычислительно-эффективным

	
	Берем по очереди целые нечетные числа (c), начиная с еденицы (еденица - не является простым числом, но в данном решении она заменит двойку) до (n - 1), и проверять их простое или непростое.
	Проверка: перебирая целые числа (k) из диапазона от (2) до (m ^ 0.5 + 1), будем делить (c) на (k) с остатком. Если остаток равен нулю, значит,  делится на  нацело -> число  непростое и переходим к проверке следующего числа.
	После успешной проверки увеличиваем счетчик на 1 (изначально счетчик приравниваем нулю).




*	
Опишите алгоритм разбиения массива длины N на k подмассивов так, чтобы размер самого длинного и самого короткого подмассива отличалась не больше чем на 1
Чему будут равны длины подмассивов?
Может ли k быть больше длины N?

	(Длина подмассива) получаем делением (N) на (k) и берем целое отбросив дробную часть.
	'''Здесь можно добавить проверку, если дробная часть равна нулю, то...'''
	(Количество остатков) получаем вычитанием (N - (k * длина подмассива)).
	В итоге получим:
	количество подмассивов длинной равной (длина массива + 1) равно количеству остатков,
	количество подмассивов длинной равной (длина массива) равно разности (k - количество остатков)
	Чему будут равны длины подмассивов: (N / k) округляем до целого вверх и вниз.
	Может ли k быть больше длины N - нет '''или часть подмассивов будет незаполненной'''.



*	
Дан массив неповторяющихся чисел, который был отсортирован, а затем циклически сдвинут на неизвестное число позиций.
Опишите без кода и псевдокода алгоритм поиска максимума в таком массиве
Оцените сложность предложенного алгоритма
Изменится ли сложность если массив содержит повторяющиеся числа?

	Сравниваем первый и средний элементы: если первый больше среднего, продолжаем поиск в первой половине (оставшегося) массива; иначе, продолжаем поиск во второй половине (оставшегося) массива.
	Продолжаем пока размер подмассива не сократиться до 1.
	Получившийся подмассив из одного элемента будет содержать максимум из исходного массива.
	
	Оцените сложность предложенного алгоритма.  логарифмическая сложность O(log n).
	Изменится ли сложность если массив содержит повторяющиеся числа? да.


*	
Напишите регулярное выражение, которое позволяет выделить все строки отвечающие условиям:

Состоят только из букв
Одна и только одна из букв является заглавной

Пример строк которые могут быть выделены выражением:

"Мама",
"авТо",
"гриБ",
'Яблоко', 'яБлоко', 'ябЛоко', 'яблОко', 'яблоКо', 'яблокО'

Пример строк которые не должны быть выделены выражением:

"агент007" - содержит цифры
"стриж" - только строчные буквы
"ГТО", - более одной заглавной буквы
"Три богатыря" - содержит пробел, допустимы только буквы

Это задание проверяется автоматическим тестированием в Python и оценивается высоко в случае прохождения всех тестов



^[а-яёa-z]*[А-ЯЁA-Z]{1}[а-яёa-z]*$











